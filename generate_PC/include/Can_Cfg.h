/**
*   @file    Can_Cfg.h
*   @version 1.0.2
*
*   @brief   AUTOSAR Can - module interface
*   @details Configuration settings generated by user settings.
*
*   @addtogroup CAN_DRIVER
*   @{
*/
/*==================================================================================================
*   Project              : AUTOSAR 4.3 MCAL
*   Platform             : ARM
*   Peripheral           : FLEXCAN
*   Dependencies         : 
*
*   Autosar Version      : 4.3.1
*   Autosar Revision     : ASR_REL_4_3_REV_0001
*   Autosar Conf.Variant :
*   SW Version           : 1.0.2
*   Build Version        : S32K1XX_MCAL_1_0_2_RTM_ASR_REL_4_3_REV_0001_23-Apr-21
*
*   (c) Copyright 2006-2016 Freescale Semiconductor, Inc. 
*       Copyright 2017-2021 NXP
*   All Rights Reserved.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
/*
@brief   (CAN023) The consistency of the configuration must be checked by the configuration tool(s).
@brief   (CAN022) The code configurator of the Can module is CAN controller specific.
         If the CAN controller is sited on-chip, the code generation tool for the Can module is Controller specific.
         If the CAN controller is an external device the generation tool must not be Controller specific.
@brief   (CAN024) The valid values that can be configured are hardware dependent.
         Therefore the rules and constraints can't be given in the standard.
         The configuration tool is responsible to do a static configuration checking, also regarding dependencies between modules (i.e. Port driver, MCU driver etc.)
*/
/*
* @file    Can_Cfg.h
*/

#ifndef CAN_CFG_H
#define CAN_CFG_H

#ifdef __cplusplus
extern "C"{
#endif

/**
* @page misra_violations MISRA-C:2004 violations
*
* @section [global]
* Violates MISRA 2004 Required Rule 5.1, Identifiers (internal and external) shall not rely 
* on the significance of more than 31 characters. The used compilers use more than 31 chars for
* identifiers.
*
* @section [global]
* Violates MISRA 2004 Required Rule 1.4, The compiler/linker shall be checked to ensure that 31 character
* signifiance and case sensitivity are supported for external identifiers.
* The used compilers use more than 31 chars for identifiers.
*
* @section Can_Cfg_h_REF_1
* Violates MISRA 2004 Required Rule 19.15, Repeated include file MemMap.h
* There are different kinds of execution code sections.
*
* @section Can_Cfg_h_REF_2
* Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined
* This violation is due to function like macros defined for pooling operations.
* Function like macros are used to reduce code complexity.
*
* @section Can_Cfg_h_REF_3
* Violates MISRA 2004 Required Rule 19.4 , The C macro expand to a variable declaration statement or 
* to a function call statement. This C macros is needed in order to have a better mentenability of the code.
*
* @section Can_Cfg_h_REF_4
* Violates MISRA 2004 Required Rule 8.7, Global variables containing the generated configuration
* shall be defined in a separate source file and can't be defined inside a function although it is accessed
* by a single function.
*
*/
/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/* @violates @ref Can_Cfg_h_REF_1 Violates MISRA 2004 Required Rule 19.15, Repeated include file MemMap.h*/
#include "Std_Types.h"
#include "Soc_Ips.h"

[!AUTOSPACING!]
[!NOCODE!][!//
[!INCLUDE "Can_VersionCheck_Inc.m"!][!//
[!ENDNOCODE!][!//

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_Cfg.h
*/
#define CAN_VENDOR_ID_CFG                       43
#define CAN_MODULE_ID_CFG                       80
#define CAN_AR_RELEASE_MAJOR_VERSION_CFG_H      4
#define CAN_AR_RELEASE_MINOR_VERSION_CFG_H      3
#define CAN_AR_RELEASE_REVISION_VERSION_CFG_H   1
#define CAN_SW_MAJOR_VERSION_CFG_H              1
#define CAN_SW_MINOR_VERSION_CFG_H              0
#define CAN_SW_PATCH_VERSION_CFG_H              2

#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    /* Check if header file and Std_Types.h file are of the same Autosar version */
    #if ((CAN_AR_RELEASE_MAJOR_VERSION_CFG_H != STD_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_AR_RELEASE_MINOR_VERSION_CFG_H != STD_AR_RELEASE_MINOR_VERSION)    \
        )
        #error "AutoSar Version Numbers of Can_Cfg.h and Std_Types.h are different"
    #endif

    /* Check if header file and Soc_Ips.h file are of the same Autosar version */
    #if ((CAN_AR_RELEASE_MAJOR_VERSION_CFG_H != SOC_IPS_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_AR_RELEASE_MINOR_VERSION_CFG_H != SOC_IPS_AR_RELEASE_MINOR_VERSION)    \
        )
        #error "AutoSar Version Numbers of Can_Cfg.h and Soc_Ips.h are different"
    #endif
#endif


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/
[!INDENT "0"!]
/**
* @brief          Can FD mode support.
* @details        This parameter is used to indicate that which controller supports FD mode.
*/
[!VAR "temp" = "0"!]
[!FOR "i" = "0" TO "ecu:get('Can.CanConfigSet.CanController') - 1"!]
    [!IF "ecu:get(concat('Can.CanConfigSet.CanFdEnableController',(substring-after(ecu:list('Can.CanConfigSet.CanHwChannelList.MSCAN')[$i+1], '_')))) = 'STD_ON'"!]
        [!VAR "temp" = "bit:or($temp, bit:shl(1, $i))"!]
    [!ENDIF!]
[!ENDFOR!]
#define CAN_FD_CONTROLLER_SUPPORTED ((uint32)[!"num:inttohex($temp, 8)"!])

/**
* @brief          Support for User Mode feature.
* @details        This parameter is enabled only in order to support the write access to some registers are protected in user mode.
*/
[!IF "(CanGeneral/CanEnableUserModeSupport = 'true') and (ecu:get('Can.CanConfig.SupvAvailable') = 'STD_ON')"!]
    #define CAN_ENABLE_USER_MODE_SUPPORT (STD_ON)
[!ELSE!]
    #define CAN_ENABLE_USER_MODE_SUPPORT (STD_OFF)
[!ENDIF!]
/**
* @brief          Support Interrupt for UNIFIED_INTERRUPTS.
* @details        This parameter is enabled only on UNIFIED_INTERRUPTS derivative.
*/
[!IF "ecu:has('Can.Interrupt.Support')='true'"!]
    #define CAN_UNIFIED_INTERRUPTS (STD_ON)
[!ELSE!]
    #define CAN_UNIFIED_INTERRUPTS (STD_OFF)
[!ENDIF!]
/**
* @brief          Support for Wakeup feature.
* @details        This parameter is enabled only for platforms which have wakeup were suppoted. This platform isn't supported Wakeup.
*/
#define CAN_ENABLE_WAKEUP_SUPPORT (STD_OFF)

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
[!WS "4"!]#if (STD_ON == CAN_ENABLE_USER_MODE_SUPPORT)
    [!WS "8"!]#error MCAL_ENABLE_USER_MODE_SUPPORT is not enabled. For running Can in user mode the MCAL_ENABLE_USER_MODE_SUPPORT needs to be defined
[!WS "4"!]#endif /* (STD_ON == CAN_ENABLE_USER_MODE_SUPPORT) */
#endif /* ifndef MCAL_ENABLE_USER_MODE_SUPPORT */ 


[!IF "ecu:has('Can.CanGeneral.CanHwUnderRegProtList')"!]
    [!VAR "numProtectedCtrl" = "0"!]
    [!VAR "listProtectedCtrl" = "ecu:get('Can.CanGeneral.CanHwUnderRegProtList')"!]
    [!VAR "numProtectedCtrl" = "count(text:split($listProtectedCtrl, ','))"!]
    [!IF "num:i($numProtectedCtrl) != 0"!]
        /**
        * @brief          Support for User Mode feature.
        * @details        This parameters are defined only at least the Can controller that has registers under REG_PROT protection.
        */
        #define CAN_FLEXCAN_REG_PROT_AVAILABLE
    [!ENDIF!]

    [!LOOP "text:split($listProtectedCtrl, ',')"!]
        #define [!WS "1"!][!"text:toupper(normalize-space(node:current()))"!]_REG_PROT_AVAILABLE[!CR!]
    [!ENDLOOP!]
[!ENDIF!]

/**
* @brief          Implicit index value used by Full can hardware objects.
* @details        Implicit index value used by Full can hardware objects.
*
*/
/* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
#define CAN_MAXMASKCOUNT    (Can_HwHandleType)65535U

/**
* @brief          Can Controllers. Defines for conversion between object names and object IDs.
* @details        Can Controllers. Defines for conversion between object names and object IDs.
                  (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file
*
*/
[!NOCODE!]
[!// Loop on all Configuration Sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    [!LOOP "CanController/*"!][!//
    [!// Loop on all channels inside the same Configuration Set
        [!VAR "SavedIndex" = "CanControllerId"!][!//
        [!VAR "Name" = "@name"!][!//
        [!// Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanController/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanControllerId)"!][!//
                    [!// Error!!!!!!!!
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for controller Ids can be repeated only if they have the same CanControllerId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
[!ENDNOCODE!]
[!/* Check if two controllers have the same name in any ConfigSet */!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanController/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanController/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter = 1"!]
            #define CanConf_CanController_[!"@name"!] ((uint8)[!"CanControllerId"!]U)[!CR!]
    [!ELSE!]
        [!WARNING!] Some controllers have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

/**
* @brief          Can Hardware Objects.
* @details        Can Hardware Objects.
                  (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file.
*
*/
[!NOCODE!][!//
// Loop on all Configuration Sets to check if the symbolic names are duplicated between config sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    // Loop on all channels inside the same Configuration Set
    [!LOOP "CanHardwareObject/*"!][!//
    [!VAR "SavedIndex" = "CanObjectId"!][!//
        [!VAR "Name" = "@name"!][!//
        // Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanHardwareObject/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanObjectId)"!][!//
                    // Error!!!!!!!!
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for hardware object Ids can be repeated only if they have the same value for CanObjectId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
 
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanHardwareObject/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanHardwareObject/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
        [!WARNING!] Some MBs have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDNOCODE!]


/*
* @brief          Symbolic names for CanObjectId
* @details        Symbolic names for CanObjectId maintained for compatibility with old testcases/applications 
*
*/
[!SELECT "CanConfigSet"!][!//
 [!LOOP "CanHardwareObject/*"!]
    #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U [!CR!]
[!ENDLOOP!]
[!ENDSELECT!]
/*
* @brief          Lpdu callout name
* @details        (CAN357_Conf) CanLPduReceiveCalloutFunction - This parameter sets the name of the LPDU callout.
*
*/
[!IF "node:exists(CanGeneral/CanLPduReceiveCalloutFunction) and (normalize-space(CanGeneral/CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
    #define CAN_LPDU_NOTIFICATION_ENABLE  (STD_ON)
[!ELSE!]
    #define CAN_LPDU_NOTIFICATION_ENABLE  (STD_OFF)
[!ENDIF!]

/*
* @brief          Extended identifiers.
* @details        Extended identifiers.
                   - (STD_ON)  - if at least one extended identifier is used.
                   - (STD_OFF) - if no extended identifiers are used at all
                  If no extended identifiers are used then the IDs and MASKs can be stored in uint16 rather than uint32.
*
*/
#define CAN_EXTENDEDID [!WS "1"!][!IF "CanGeneral/CanExtendedIDSupport = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

#define CAN_SET_BAUDRATE_API [!WS "1"!][!IF "((node:exists(CanGeneral/CanSetBaudrateApi)) and (CanGeneral/CanSetBaudrateApi ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Switches the Development Error Detection and Notification ON or OFF.
* @details        (CAN028) Call the Development Error Tracer when DET is switched on and the Can module detects an error.
                  (CAN082) The detection of development errors is configurable (ON / OFF) at pre- compile time.
                  The switch CanDevErrorDetection (see chapter 10) shall activate or deactivate the detection of all development errors.
*
*/
#define CAN_DEV_ERROR_DETECT [!WS "1"!][!IF "CanGeneral/CanDevErrorDetect = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          CAN driver support for multiple INTERRUPTs.
* @details        CAN driver support for multiple INTERRUPTs.
*
*/
#define CAN_MULTIPLE_INTERRUPTS_SUPPORT [!WS "1"!][!IF "ecu:get('Can.CanConfig.MultipleInterrupts')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Extended number of can hardware objects
* @details        Extended number of can hardware objects:
                   - STD_ON if more than 256 can hardware objects are needed (up to 65536)
                   - STD_OFF if no more than 256 can hardware objects are needed
                   The specification only allows up to 256 can hardware objects. The driver supports a non-standard extension of this limit.
@violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability.
*
*/
#define CAN_MBCOUNTEXTENSION [!WS "1"!][!IF "CanGeneral/CanMBCountExtensionSupport = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for version info API
* @details        Switches the Can_GetVersionInfo() API ON or OFF.
*
*/
#define CAN_VERSION_INFO_API [!WS "1"!][!IF "CanGeneral/CanVersionInfoApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for Multiplexed Transmision
* @details        MB set for Tx is put on bus from any TxMB that is available (free).
*                 (CAN277) The Can module shall allow that the functionality Multiplexed Transmission is statically configurable (ON | OFF) at pre-compile time.
*
*/
#define CAN_MULTIPLEXED_TRANSMISSION [!WS "1"!][!IF "CanGeneral/CanMultiplexedTransmission = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for Transmision Cancellation
* @details        Support for Transmision Cancellation
*                 (CAN278) The Can module shall allow that the functionality Transmit Cancellation is statically configurable (ON | OFF) at pre-compile time.
*
*/
#define CAN_HW_TRANSMIT_CANCELLATION (STD_OFF)

/*
* @brief          Support for Identical Id Cancellation
* @details        Enables/disables cancellation of pending PDUs with identical ID.
*
*/

/*
* @brief          Support for Special MB Abort API
* @details        Enable an additional API, to write an ABORT code (b1001) to the MBCB filed of the MB to abort a message transmission.
*
*/
#define CAN_API_ENABLE_ABORT_MB [!WS "1"!][!IF "(CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for MB Abort  API
* @details         This parameter is enabled only if CanMultiplexedTransmission=STD_ON and aborts only one message buffer
*/
#define CAN_ABORT_ONLY_ONE_MB [!WS "1"!][!IF "(CanGeneral/CanAbortOnlyOneMB = 'true') and (CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Instance # of the driver - used for Det_ReportError().
* @details        Instance # of the driver - used for Det_ReportError().
*
*/
#define CAN_INSTANCE [!WS "1"!][!"num:i(CanGeneral/CanIndex)"!]U

/*
* @brief          The define in order to check the trigger transmit feature is enabled or disabled.
* @details        The define in order to check the trigger transmit feature is enabled or disabled.
*
*/
[!IF "num:i(count(CanConfigSet/CanHardwareObject/*[CanTriggerTransmitEnable = 'true'])) > 0"!]
    #define CAN_TRIGGER_TRANSMIT_EN (STD_ON)
[!ELSE!]
    #define CAN_TRIGGER_TRANSMIT_EN (STD_OFF)
[!ENDIF!]

/*
* @brief          Platform support mix of controllers with 64 and 32 MBs.
* @details        Platform support mix of controllers with 64 and 32 MBs.
*
*/
#define CAN_MIX_MB_SUPPORT  [!WS "1"!][!IF "ecu:get('Can.CanConfig.MixMB')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Platform support for detection and correction of memory errors
* @details        Platform support for detection and correction of memory errors
*
*/
#define CAN_MEMORY_ECC_SUPPORT  [!WS "1"!][!IF "ecu:get('Can.CanConfig.MemoryECC')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

[!IF "ecu:has('Can.CanGeneral.FixNoFifoFilterAndMask')"!][!//
    [!IF "ecu:get('Can.CanGeneral.FixNoFifoFilterAndMask')='STD_ON'"!][!//
        /*
        * @brief          Platform not support Selectable number of Fifo filter element and Global Fifo filter mask
        * @details        Platform not support Selectable number (fix to 8 filter elements) of Fifo filter element and Global Fifo filter mask
        *
        */

        #define CAN_NOT_SUPPORT_CTRL2_RXFGMASK  [!WS "1"!](STD_ON)
    [!ENDIF!][!//
[!ENDIF!][!//

/*
* @brief          Disable errata e10368 in some derivative
* @details        In some derivative, it is not impacted by errata e10368. This define is for removing workaround when using these derivative.
*
*/
[!IF "ecu:has('Can.CanGeneral.DisableE10368')"!][!//
    [!IF "ecu:get('Can.CanGeneral.DisableE10368')='STD_ON'"!][!//
        #define CAN_E10368_INCONSISTENT  [!WS "1"!](STD_ON)
    [!ELSE!]
        #define CAN_E10368_INCONSISTENT  [!WS "1"!](STD_OFF)
    [!ENDIF!][!//
[!ELSE!]
        #define CAN_E10368_INCONSISTENT  [!WS "1"!](STD_OFF)
[!ENDIF!][!//


/*
* @brief          Platform support for Pretended Networking
* @details        Platform support for Pretended Networking
*
*/
[!IF "(CanGeneral/CanPublicIcomSupport  = 'true') and (ecu:get('Can.CanConfigSet.CanPretendedNetworking')='STD_ON')"!]
  [!SELECT "CanConfigSet"!]
    [!IF "node:exists(CanIcom)"!]
        #define CAN_PRETENDED_MAX_CONFIG    ((uint8)[!"num:i(count(CanIcom/CanIcomConfig/*))"!]U)
      [!IF "node:exists(CanIcom/CanIcomConfig/*/CanIcomWakeupCauses/CanIcomRxMessage/*/CanIcomMissingMessageTimerValue)"!]
        #define CAN_PRETENDED_TIMEOUT_CHECK (STD_ON)
      [!ELSE!]
        #define CAN_PRETENDED_TIMEOUT_CHECK (STD_OFF)
      [!ENDIF!]
        [!IF "node:exists(CanIcom/CanIcomConfig/*/CanIcomWakeupCauses/CanIcomRxMessage/*/CanIcomCounterValue)"!]
            #define CAN_PRETENDED_COUNT_MESSAGE (STD_ON)
        [!ELSE!]
            #define CAN_PRETENDED_COUNT_MESSAGE (STD_OFF)
        [!ENDIF!]
    [!ELSE!]
        #define CAN_PRETENDED_TIMEOUT_CHECK (STD_OFF)
    [!ENDIF!]
  [!ENDSELECT!]
[!ENDIF!]
/*
* @brief          Maximum number of Message Buffers configured.
* @details        Maximum number of Message Buffers configured.
*
*/
[!SELECT "CanConfigSet"!]
    [!VAR "max_ctrl" = "ecu:get('Can.CanConfigSet.CanController')"!]
    [!VAR "ctrls" = "num:i(count(CanController/*))"!][!VAR "mbs" = "num:i(count(CanHardwareObject/*))"!]
    [!IF "( ($ctrls > $max_ctrl) or ($mbs > ($ctrls*(ecu:get('Can.CanConfigSet.CanMB')))) )"!]
        [!ERROR!]Too many MBs for the number of controllers configured.[!ENDERROR!]
    [!ELSE!]
        #define CAN_MAXMBCOUNT_0 [!WS "1"!][!"num:i(count(CanHardwareObject/*))"!]U
    [!ENDIF!]
[!ENDSELECT!]


/*
* @brief          Maximum possible Message Buffers per controller specific to this platform.
* @details        Maximum possible Message Buffers per controller specific to this platform.
*
*/
[!VAR "max_mb_value" = "num:i(ecu:get('Can.CanConfigSet.CanMB'))"!]
[!IF "($max_mb_value <=32)"!]
    #define CAN_MAXMB_SUPPORTED 32U
[!ELSEIF "(($max_mb_value > 32) and ($max_mb_value <=64))"!]
    #define CAN_MAXMB_SUPPORTED 64U
[!ELSEIF "(($max_mb_value > 64) and ($max_mb_value <=96))"!]
    #define CAN_MAXMB_SUPPORTED 96U
[!ENDIF!]

/*
* @brief          Maximum number of Message Buffers configured.
* @details        Maximum number of Message Buffers configured.
*
*/
#define CAN_MAXMB_CONFIGURED [!WS "1"!][!SELECT "CanGeneral"!][!"num:i(CanMaxMessageBuffers)"!]U[!ENDSELECT!][!CR!]

/*
* @brief          Maximum possible controllers per specific derivative.
* @details        Maximum possible controllers per specific derivative.
*
*/
#define CAN_MAXCTRL_SUPPORTED [!WS "1"!][!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!]U

/**
* @brief          Maximum No. of supported controllers (vary according to Processor Family).
* @details        Maximum No. of supported controllers (vary according to Processor Family).
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT='VariantPreCompile'"!]
    [!SELECT "CanConfigSet"!][!//
        [!VAR "ctrls" = "num:i(count(CanController/*))"!]
        [!IF "$ctrls > $max_ctrl"!]
            [!ERROR!]Target supports maximum [!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!] controllers.[!ENDERROR!]
        [!ELSE!]
            #define CAN_MAXCONTROLLERCOUNT_0 [!WS "1"!][!"$ctrls"!]U[!CR!]
        [!ENDIF!]
    [!ENDSELECT!]
[!ELSE!]
    [!SELECT "CanConfigSet"!][!//
        [!VAR "ctrls" = "num:i(count(CanController/*))"!]
        [!IF "$ctrls > $max_ctrl"!]
            [!ERROR!]Target supports maximum [!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!] controllers.[!ENDERROR!]
        [!ELSE!]
            #define CAN_MAXCONTROLLERCOUNT_0 [!WS "1"!][!"$ctrls"!]U[!CR!]
        [!ENDIF!]
    [!ENDSELECT!]
[!ENDIF!]

/*
* @brief          Maximum No. of controllers Configured
* @details      Maximum No. of controllers Configured
*
*/
[!NOCODE!]
[!VAR "flexcans" = "0"!]
[!SELECT "CanConfigSet"!]
    [!VAR "flexcans" = "num:i(count(CanController/*))"!] 
[!ENDSELECT!]
[!ENDNOCODE!]
#define CAN_MAXCTRL_CONFIGURED [!WS "1"!][!"$flexcans"!]U

[!IF "IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile' and (variant:size()<=1)"!]
    /**
    * @brief          Hardware events detected by an INTERRUPT or by POLLING
    * @details        (CAN099) The hardware events may be detected by an INTERRUPT or by POLLING status flags of the hardware objects.
    *                 The configuration possibilities regarding POLLING is hardware dependent (i.e. which events can be polled, which events need to be polled), and not restricted by this standard.
    *                 (CAN007)It shall be possible to configure the driver such that no INTERRUPTs at all are used (complete POLLING).
    *
    */
    [!NOCODE!]
    [!VAR "int_en_a"="0"!]
    [!VAR "int_en_b"="0"!]
    [!VAR "int_en_c"="0"!]
    [!VAR "int_en_d"="0"!]
    [!VAR "int_en_e"="0"!]
    [!VAR "int_en_f"="0"!]
    [!VAR "int_en_g"="0"!]
    [!VAR "int_en_h"="0"!]
    [!VAR "tx_int_en" = "0"!]
    [!SELECT "CanConfigSet"!]
        [!LOOP "CanHardwareObject/*"!]
            [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                [!VAR "tx_int_en" = "1"!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_A'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_a"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_B'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_b"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_C'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_c"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_D'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_d"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_E'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_e"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_F'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_f"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_G'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_g"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_H'"!]
                [!IF "(node:ref(CanControllerRef)/CanTxProcessing != 'POLLING') and (CanObjectType = 'TRANSMIT') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_h"="1"!]
                [!ENDIF!]
            [!ENDIF!]      
        [!ENDLOOP!]
    [!ENDSELECT!]
    [!ENDNOCODE!]
    /**
    * @brief          This macros enable INTERRUPTs for controllers if Tx processing is set to INTERRUPT Mode.
    * @details        This macros enable INTERRUPTs for controllers if Tx processing is set to INTERRUPT Mode.
    *
    */
    [!SELECT "CanConfigSet"!]
        [!LOOP "CanController/*"!]
            [!IF "CanHwChannel = 'FlexCAN_A'"!]#define CAN_A_TXINT_SUPPORTED  [!IF "$int_en_a = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_B'"!]#define CAN_B_TXINT_SUPPORTED  [!IF "$int_en_b = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_C'"!]#define CAN_C_TXINT_SUPPORTED  [!IF "$int_en_c = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_D'"!]#define CAN_D_TXINT_SUPPORTED  [!IF "$int_en_d = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_E'"!]#define CAN_E_TXINT_SUPPORTED  [!IF "$int_en_e = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_F'"!]#define CAN_F_TXINT_SUPPORTED  [!IF "$int_en_f = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_G'"!]#define CAN_G_TXINT_SUPPORTED  [!IF "$int_en_g = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_H'"!]#define CAN_H_TXINT_SUPPORTED  [!IF "$int_en_h = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
        [!ENDLOOP!]
    [!ENDSELECT!]

    /**
    * @brief          This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in POLLING Mode.
    * @details        This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in POLLING Mode.
    *
    */
    [!NOCODE!]
    [!VAR "tx_pol_en" = "0"!]
    [!SELECT "CanConfigSet"!]
        [!LOOP "CanHardwareObject/*"!]
            [!IF "(node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'true' and node:value(CanObjectType) = 'TRANSMIT') or node:ref(CanControllerRef)/CanTxProcessing = 'POLLING'"!]
                [!VAR "tx_pol_en" = "1"!]
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDSELECT!]
    [!ENDNOCODE!]
    #define CAN_TXPOLL_SUPPORTED   [!IF "$tx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

    [!NOCODE!]
    [!VAR "int_en_a"="0"!]
    [!VAR "int_en_b"="0"!]
    [!VAR "int_en_c"="0"!]
    [!VAR "int_en_d"="0"!]
    [!VAR "int_en_e"="0"!]
    [!VAR "int_en_f"="0"!]
    [!VAR "int_en_g"="0"!]
    [!VAR "int_en_h"="0"!]
    [!VAR "rx_int_en" = "0"!]
    [!SELECT "CanConfigSet"!]
        [!LOOP "CanHardwareObject/*"!]
            [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                [!VAR "rx_int_en" = "1"!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_A'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_a"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_B'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_b"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_C'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_c"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_D'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_d"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_E'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_e"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_F'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_f"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_G'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_g"="1"!]
                [!ENDIF!]
            [!ENDIF!]
            [!IF "node:ref(CanControllerRef)/CanHwChannel = 'FlexCAN_H'"!]
                [!IF "(node:ref(CanControllerRef)/CanRxProcessing != 'POLLING') and (CanObjectType = 'RECEIVE') and (not(node:exists(CanHardwareObjectUsesPolling)) or (node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'false'))"!]
                    [!VAR "int_en_h"="1"!]
                [!ENDIF!]
            [!ENDIF!]   
        [!ENDLOOP!]
    [!ENDSELECT!]
    [!ENDNOCODE!]
    /**
    * @brief          This macros enable INTERRUPTs for controllers if Rx processing is set to INTERRUPT Mode.
    * @details        This macros enable INTERRUPTs for controllers if Rx processing is set to INTERRUPT Mode.
    *
    */
    [!SELECT "CanConfigSet"!]
        [!LOOP "CanController/*"!]
            [!IF "CanHwChannel = 'FlexCAN_A'"!]#define CAN_A_RXINT_SUPPORTED  [!IF "$int_en_a = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_B'"!]#define CAN_B_RXINT_SUPPORTED  [!IF "$int_en_b = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_C'"!]#define CAN_C_RXINT_SUPPORTED  [!IF "$int_en_c = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_D'"!]#define CAN_D_RXINT_SUPPORTED  [!IF "$int_en_d = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_E'"!]#define CAN_E_RXINT_SUPPORTED  [!IF "$int_en_e = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_F'"!]#define CAN_F_RXINT_SUPPORTED  [!IF "$int_en_f = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_G'"!]#define CAN_G_RXINT_SUPPORTED  [!IF "$int_en_g = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_H'"!]#define CAN_H_RXINT_SUPPORTED  [!IF "$int_en_h = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
        [!ENDLOOP!]
    [!ENDSELECT!]

    /*
    * @brief          This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in POLLING Mode.
    * @details        This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in POLLING Mode.
    *
    */
    [!NOCODE!]
    [!VAR "rx_pol_en" = "0"!]
    [!SELECT "CanConfigSet"!]
        [!LOOP "CanHardwareObject/*"!]
            [!IF "(node:exists(CanHardwareObjectUsesPolling) and node:value(CanHardwareObjectUsesPolling) = 'true' and node:value(CanObjectType) = 'RECEIVE') or node:ref(CanControllerRef)/CanRxProcessing = 'POLLING'"!]
                [!VAR "rx_pol_en" = "1"!]
            [!ENDIF!]
        [!ENDLOOP!]
    [!ENDSELECT!]
    [!ENDNOCODE!]
    #define CAN_RXPOLL_SUPPORTED   [!IF "$rx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

    /*
    * @brief          This macro enables Can_ProcessTx() and Can_ProcessRx() if at least one controller is set to process TX/Rx in INTERRUPT Mode.
    * @details        This macro enables Can_ProcessTx() and Can_ProcessRx() if at least one controller is set to process TX/Rx in INTERRUPT Mode.
    *
    */
    [!IF "($tx_int_en = 1) or ($rx_int_en = 1)"!]
        #define CAN_TX_RX_INTR_SUPPORTED    (STD_ON)
    [!ELSE!]
        #define CAN_TX_RX_INTR_SUPPORTED    (STD_OFF)
    [!ENDIF!]
[!ELSE!]
    [!SELECT "CanConfigSet"!]
        [!VAR "tx_pol_en" = "0"!]
        [!VAR "rx_pol_en" = "0"!]
        /**
        * @brief          This macros enable INTERRUPTs for controllers if Tx processing is set to INTERRUPT Mode.
        * @details        This macros enable INTERRUPTs for controllers if Tx processing is set to INTERRUPT Mode.
        *
        */
        [!LOOP "CanController/*"!]
            [!IF "CanHwChannel = 'FlexCAN_A'"!]#define CAN_A_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_B'"!]#define CAN_B_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_C'"!]#define CAN_C_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_D'"!]#define CAN_D_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_E'"!]#define CAN_E_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_F'"!]#define CAN_F_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_G'"!]#define CAN_G_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_H'"!]#define CAN_H_TXINT_SUPPORTED  [!IF "CanTxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
        [!ENDLOOP!]
        
        /**
        * @brief          This macros enable INTERRUPTs for controllers if Rx processing is set to INTERRUPT Mode.
        * @details        This macros enable INTERRUPTs for controllers if Rx processing is set to INTERRUPT Mode.
        *
        */
        [!LOOP "CanController/*"!]
            [!IF "CanHwChannel = 'FlexCAN_A'"!]#define CAN_A_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_B'"!]#define CAN_B_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_C'"!]#define CAN_C_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_D'"!]#define CAN_D_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_E'"!]#define CAN_E_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_F'"!]#define CAN_F_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_G'"!]#define CAN_G_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
            [!IF "CanHwChannel = 'FlexCAN_H'"!]#define CAN_H_RXINT_SUPPORTED  [!IF "CanRxProcessing != 'POLLING'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
        [!ENDLOOP!]
        
        /*
        * @brief          This macro enables Can_ProcessTx() and Can_ProcessRx() if at least one controller is set to process TX/Rx in INTERRUPT Mode.
        * @details        This macro enables Can_ProcessTx() and Can_ProcessRx() if at least one controller is set to process TX/Rx in INTERRUPT Mode.
        *
        */
        [!IF "num:i(count(CanController/*[CanTxProcessing != 'POLLING' or CanRxProcessing != 'POLLING'])) != 0"!]
            #define CAN_TX_RX_INTR_SUPPORTED    (STD_ON)
        [!ELSE!]
            #define CAN_TX_RX_INTR_SUPPORTED    (STD_OFF)
        [!ENDIF!]
        
        /**
        * @brief          This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in POLLING Mode.
        * @details        This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in POLLING Mode.
        *
        */
        [!IF "num:i(count(CanController/*[CanTxProcessing != 'INTERRUPT'])) != 0"!]
            [!VAR "tx_pol_en" = "1"!]
            #define CAN_TXPOLL_SUPPORTED    (STD_ON)
        [!ELSE!]
            #define CAN_TXPOLL_SUPPORTED    (STD_OFF)
        [!ENDIF!]
        
        /*
        * @brief          This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in POLLING Mode.
        * @details        This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in POLLING Mode.
        *
        */
        [!IF "num:i(count(CanController/*[CanRxProcessing != 'INTERRUPT'])) != 0"!]
            [!VAR "rx_pol_en" = "1"!]
            #define CAN_RXPOLL_SUPPORTED    (STD_ON)
        [!ELSE!]
            #define CAN_RXPOLL_SUPPORTED    (STD_OFF)
        [!ENDIF!]
        
    [!ENDSELECT!]
[!ENDIF!]

[!NOCODE!]
[!VAR "int_en_a"="0"!]
[!VAR "int_en_b"="0"!]
[!VAR "int_en_c"="0"!]
[!VAR "int_en_d"="0"!]
[!VAR "int_en_e"="0"!]
[!VAR "int_en_f"="0"!]
[!VAR "int_en_g"="0"!]
[!VAR "int_en_h"="0"!]
[!VAR "bo_pol_en"="0"!]
[!VAR "bo_int_en"="0"!]
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!IF "CanBusoffProcessing = 'POLLING'"!]
            [!VAR "bo_pol_en" = "1"!]
        [!ELSE!]
            [!VAR "bo_int_en" = "1"!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_a" = "1"!]
            [!ELSE!]
                [!VAR "int_en_a" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_b" = "1"!]
            [!ELSE!]
                [!VAR "int_en_b" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_c" = "1"!]
            [!ELSE!]
                [!VAR "int_en_c" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_d" = "1"!]
            [!ELSE!]
                [!VAR "int_en_d" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_e" = "1"!]
            [!ELSE!]
                [!VAR "int_en_e" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_f" = "1"!]
            [!ELSE!]
                [!VAR "int_en_f" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_G'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_g" = "1"!]
            [!ELSE!]
                [!VAR "int_en_g" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_H'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_h" = "1"!]
            [!ELSE!]
                [!VAR "int_en_h" = "2"!]
            [!ENDIF!]
        [!ENDIF!]   
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
/**
* @brief          This macros enable INTERRUPTs for controllers if BusOff processing is set to INTERRUPT Mode.
* @details        This macros enable INTERRUPTs for controllers if BusOff processing is set to INTERRUPT Mode.
*
*/
[!IF "$int_en_a!=0"!]#define CAN_A_BUSOFFINT_SUPPORTED  [!IF "$int_en_a = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_BUSOFFINT_SUPPORTED  [!IF "$int_en_b = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_BUSOFFINT_SUPPORTED  [!IF "$int_en_c = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_BUSOFFINT_SUPPORTED  [!IF "$int_en_d = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_BUSOFFINT_SUPPORTED  [!IF "$int_en_e = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_BUSOFFINT_SUPPORTED  [!IF "$int_en_f = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_g!=0"!]#define CAN_G_BUSOFFINT_SUPPORTED  [!IF "$int_en_g = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_g = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_h!=0"!]#define CAN_H_BUSOFFINT_SUPPORTED  [!IF "$int_en_h = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_h = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]

/*
* @brief          This macro enables Can_MainFunction_BusOff() if at least one controller is set to process BusOff in POLLING Mode.
* @details        This macro enables Can_MainFunction_BusOff() if at least one controller is set to process BusOff in POLLING Mode.
*
*/
#define CAN_BUSOFFPOLL_SUPPORTED   [!IF "$bo_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          This macro enables BusOff ISR if at least one controller is set to process BusOff in INTERRUPT Mode.
* @details        This macro enables BusOff ISR if at least one controller is set to process BusOff in INTERRUPT Mode.
*
*/
#define CAN_BUSOFFINT_SUPPORTED   [!IF "$bo_int_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]
/*
* @brief          Maximum number of MB Filters configured.
* @details        Maximum number of MB Filters configured.
*
*/
[!SELECT "CanConfigSet"!]
    #define CAN_MAXFILTERCOUNT_0 [!WS "1"!][!"num:i(count(CanHardwareObject/*/CanHwFilter))"!]U[!CR!]
[!ENDSELECT!]

/**
* @brief          Maximum number of baudrate configured.
* @details        Maximum number of baudrate configured.
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT='VariantPreCompile'"!]
    [!SELECT "CanConfigSet"!][!//
        [!LOOP "CanController/*"!]
            [!VAR "HWChannel" = "CanHwChannel"!]
                #define CAN_CFGSET0_MAX_BAUDRATE_FC_[!"substring-after($HWChannel,'FlexCAN_')"!]_[!"@index"!]   [!WS "1"!][!"num:i(count(CanControllerBaudrateConfig/*))"!]U[!CR!]
        [!ENDLOOP!]
    [!ENDSELECT!]
[!ELSE!]
    [!SELECT "CanConfigSet"!][!//
        [!VAR "CSET_NR" = "num:i(0)"!]
        [!LOOP "CanController/*"!]
            [!VAR "HWChannel" = "CanHwChannel"!]
            #define CAN_CFGSET[!"num:i($CSET_NR)"!]_MAX_BAUDRATE_FC_[!"substring-after($HWChannel,'FlexCAN_')"!]_[!"@index"!]   [!WS "1"!][!"num:i(count(CanControllerBaudrateConfig/*))"!]U[!CR!]
        [!ENDLOOP!]
    [!ENDSELECT!] 
[!ENDIF!]

/* CAN FD INIT*/
[!NOCODE!]
[!VAR "CNT_FD" = "0"!]
[!SELECT "CanConfigSet"!][!//
[!IF "ecu:get('Can.CanConfigSet.CanFdEnable')='STD_ON'"!]
    [!IF "node:exists(CanController/*/CanControllerBaudrateConfig/*/CanControllerFdBaudrateConfig)"!]
        [!VAR "CNT_FD" = "$CNT_FD+1"!] 
    [!ENDIF!]
[!ENDIF!]    
[!ENDSELECT!]
[!ENDNOCODE!]
[!IF "$CNT_FD > 0"!]
    #define CAN_FD_MODE_ENABLE (STD_ON)
    [!VAR "CNT_FD" = "0"!]
[!ELSE!]
    #define CAN_FD_MODE_ENABLE (STD_OFF)
[!ENDIF!]

[!IF "ecu:get('Can.CanConfig.SwichingIsoMode')='STD_ON'"!]
    #define CAN_CONTROLLER_FD_ISO_CANFD (STD_ON)
[!ELSE!]
    #define CAN_CONTROLLER_FD_ISO_CANFD (STD_OFF)
[!ENDIF!]

[!IF "ecu:get('Can.CanConfigSet.ProtocolException')='STD_ON'"!]
    #define CAN_CONTROLLER_FD_PREXCEN (STD_ON)
[!ELSE!]
    #define CAN_CONTROLLER_FD_PREXCEN (STD_OFF)
[!ENDIF!]

[!IF "ecu:get('Can.CanConfigSet.EdgeFilter')='STD_ON'"!]
    #define CAN_CONTROLLER_FD_EDFLTDIS (STD_ON)
[!ELSE!]
    #define CAN_CONTROLLER_FD_EDFLTDIS (STD_OFF)
[!ENDIF!]

/*
* @brief          Maximum number of Filters configured for RxFifo.
* @details        Maximum number of Filters configured for RxFifo.
*
*/
[!SELECT "CanConfigSet"!][!VAR "TableIdCount" = "0"!]
    [!LOOP "CanController/*"!]
        [!IF "CanControllerRxFifoEnable = 'true'"!]
            [!VAR "TableIdCount" = "$TableIdCount+num:i(substring-after(./CanRxFifo/CanRxFifoFiltersNumber,'FILTERS_NUMBER_'))"!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$TableIdCount != 0"!]
        #define CAN_MAXTABLEID_0 [!WS "1"!][!"num:i($TableIdCount)"!]U[!CR!]
    [!ENDIF!]
[!ENDSELECT!]

[!VAR "rxfifoenable" = "0"!]
[!LOOP "CanConfigSet/CanController/*"!]
    [!IF "CanControllerRxFifoEnable = 'true'"!]
        [!VAR "rxfifoenable" = "1"!]
    [!ENDIF!]
[!ENDLOOP!]

/*
* @brief          Support for Rx Fifo
* @details        Support for Rx Fifo - If at least one controller supports RxFifo, then this define is set to STD_ON.
*                 This define is global for the entire hardware unit (all controllers). Every controller has particular
*                 configuration for Rx Fifo (see Can_ControllerConfigType structure).
*
*/
#define CAN_RXFIFO_ENABLE [!IF "$rxfifoenable = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Set if Rx Fifo events (Warning/Overflow/FrameAvailable) are configured on the same int on INTC vector table.
* @details        Set if Rx Fifo events (Warning/Overflow/FrameAvailable) are configured on the same int on INTC vector table.
*                 Based on this define separate INTERRUPTs handlers or not will be used for the 3 events of the RxFifo.
*
*/
#define CAN_RXFIFO_EVENT_UNIFIED [!WS "1"!][!IF "ecu:get('Can.CanConfigSet.RxFifoEventsUnified')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Error notification enabled/disabled.
* @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
*
*/
#define CAN_ERROR_NOTIFICATION_ENABLE [!IF "CanConfigSet/CanController/*/CanErrorControllerNotifEn = 'true'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.Indexes used for accessing the 'Can_ControlerDescriptorType' structure.
            *                 NOTE that index order from hardware (where CAN_A has always index 0, ..)
            *                 may not be the same with the order from the 'Can_ControlerDescriptorType' structure (where user can define controllers in any order).
            *                 Count also the number of controllers that have INTERRUPTs enabled.
            *
            */
            #define CAN_FCA_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)

            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.Indexes used for accessing the 'Can_ControlerDescriptorType' structure.
            *
            */
            #define FLEXCAN_A_OFFSET    ((uint8)0U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_A_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_A_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_B'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCB_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_B_OFFSET    ((uint8)1U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_B_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_B_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_C'"!]
            /*
            * @brief          Index into the configuration structures
            * @details        Index into the configuration structures
            *
            */
            #define CAN_FCC_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
          
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_C_OFFSET    ((uint8)2U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_C_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_C_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_D'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCD_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_D_OFFSET    ((uint8)3U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_D_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_D_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_E'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCE_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_E_OFFSET    ((uint8)4U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_E_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_E_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_F'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCF_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_F_OFFSET    ((uint8)5U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_F_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_F_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_G'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCG_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_G_OFFSET    ((uint8)6U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_G_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_G_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_H'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCH_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_H_OFFSET    ((uint8)7U)
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            
            #define CAN_H_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_H_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]

/*
* @brief          Optimization of INTERRUPT service code for size.
* @details        Optimization of INTERRUPT service code for size.
*
*/
#define CAN_ISROPTCODESIZE [!WS "1"!][!IF "CanGeneral/CanCodeSizeOptimization = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Enable Non-Autosar API for Dual-Clock support.
* @details        Enable Non-Autosar API for Dual-Clock support.
*                 This can be set to STD_ON only if it is activated from Resource file (Can.CanConfig.DualClockMode = STD_ON)
*
*/
#define CAN_DUAL_CLOCK_MODE [!WS "1"!][!IF "ecu:get('Can.CanConfig.DualClockMode')='STD_ON'"!][!IF "CanGeneral/CanEnableDualClockMode = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!ELSE!](STD_OFF)[!ENDIF!][!CR!]


[!IF "ecu:has('Can.CanConfig.CtrlClksrcAvailable')='true'"!]
    [!IF "ecu:get('Can.CanConfig.CtrlClksrcAvailable')='STD_ON'"!]
        /* This macro is only defined if it is activated from Resource file (Can.CanConfig.DualClockMode = STD_ON) */
        #define CAN_FLEXCAN_CLKSRC_AVAIABLE
    [!ENDIF!]
[!ENDIF!]


[!IF "CanGeneral/CanAllowLoopAsCycle = 'true'"!][!// if select the TimeOut as loop cycle
/*
* @brief          Specifies the maximum time for blocking function until a timeout is detected (implement as loop cycles).
* @details        The Can module shall use the free running timer provided by the system service for timeout detection in case the hardware does not react
*                  in the expected time (hardware malfunction) to prevent endless loops.
*
*/
#if defined(ERR_IPV_FLEXCAN_0008)
    [!WS "4"!]#if (ERR_IPV_FLEXCAN_0008 == STD_ON)
    [!WS "8"!]    #define CAN_TIMEOUT_DURATION 50000U
    [!WS "4"!]#else
    [!WS "8"!]    #error: The define ERR_IPV_FLEXCAN_0008 should not be STD_OFF
    [!WS "4"!]#endif
#else
    [!WS "4"!]#define CAN_TIMEOUT_DURATION [!SELECT "CanGeneral"!][!"num:i(CanNumberOfTimeOutLoop)"!]U[!ENDSELECT!][!CR!]
#endif /* ERR_IPV_FLEXCAN_0008 */
/*
* @brief          Define timeout as loop
* @details        Define that timeout implemented as loop cycle
*
*/
    [!WS "4"!]#define CAN_TIMEOUT_AS_LOOP   (STD_ON)
[!ELSE!][!// default case, when using counter from OS
/*
* @brief          Specifies the maximum time for blocking function until a timeout is detected (implement as second).
* @details        The Can module shall use the free running timer provided by the system service for timeout detection in case the hardware does not react
*                  in the expected time (hardware malfunction) to prevent endless loops.
*
*/
    [!WS "4"!]#define CAN_TIMEOUT_DURATION [!SELECT "CanGeneral"!][!"CanTimeoutDuration * 1000000000"!]F[!ENDSELECT!][!CR!]
    
  [!SELECT "node:ref(CanGeneral/CanOsCounterRef)"!][!//
/*
* @brief          Reference to OS counter
* @details        Define the OS counter used by Candriver
*
*/
    /*
    * @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. 
    * @violates @ref Can_Cfg_h_REF_2 Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.
    */
    [!WS "4"!]#define CAN_TIMEOUT_COUNTER_NAME   [!"@name"!]
/*
* @brief          Wrap macro to convert TimeOut
* @details        Define the ns time specify by 1 tick
*
*/
    /*
    * @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. 
    * @violates @ref Can_Cfg_h_REF_2 Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.
    */
    [!WS "4"!]#define CAN_TIMEOUT_COUNTER_TICK2NS()   OS_TICKS2NS_[!"@name"!](1U)
  [!ENDSELECT!][!//
[!ENDIF!][!//

/*
* @brief          Precompile Support.
* @details        (CAN220)VARIANT-PRE-COMPILE: Only pre-compile configuration parameters
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile' and (variant:size()<=1)"!]
    #define CAN_PRECOMPILE_SUPPORT (STD_ON)
[!ELSE!]
    #define CAN_PRECOMPILE_SUPPORT (STD_OFF)
[!ENDIF!]

[!MACRO "CanExportDriverConfiguration"!]
[!NOCODE!][!//
[!VAR "configName" = "as:name(CanConfigSet)"!][!//
[!CODE!][!//
/* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
#define CAN_CONF_PB \
[!ENDCODE!][!//
[!IF "var:defined('postBuildVariant')"!][!//
    [!VAR "variantIndex"="0"!][!//
    [!VAR "variantNumber"="variant:size()"!][!//
    [!LOOP "variant:all()"!][!VAR "variantIndex"="$variantIndex + 1"!][!//
    [!//
        [!CODE!][!WS4!]extern CONST(Can_ConfigType, CAN_CONST) Can_Config_[!"."!];[!IF "$variantIndex < $variantNumber"!]\[!ENDIF!][!CR!][!ENDCODE!]
    [!ENDLOOP!][!//
[!ELSE!][!//
    [!CODE!][!WS4!]extern CONST(Can_ConfigType, CAN_CONST) Can_Config;[!CR!][!ENDCODE!]
[!ENDIF!][!//
[!ENDNOCODE!][!//
[!ENDMACRO!]

[!IF "((IMPLEMENTATION_CONFIG_VARIANT != 'VariantPostBuild') and (variant:size()>1)) or (IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild')"!]
    [!CALL "CanExportDriverConfiguration"!]
[!ENDIF!]

[!IF "node:exists(CanGeneral/CanMainFunctionBusoffPeriod)"!]
    /*
    * @brief          Periods for cyclic call of Main function
    * @details        (CAN355_Conf) CanMainFunctionBusoffPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Busoff. Unit is seconds.
    *
    */
    #define CAN_MAINFUNCTION_PERIOD_BUSOFF  [!WS "1"!][!SELECT "CanGeneral"!]([!"num:i(CanMainFunctionBusoffPeriod)"!]U)[!ENDSELECT!][!CR!]
[!ENDIF!]

[!IF "(CanGeneral/CanPublicIcomSupport='true') and (ecu:get('Can.CanConfigSet.CanPretendedNetworking')='STD_ON')"!]
    /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
    #define CAN_PUBLIC_ICOM_SUPPORT  (STD_ON)
[!ELSE!]
    #define CAN_PUBLIC_ICOM_SUPPORT  (STD_OFF)
[!ENDIF!]

/*
* @brief          Periods for cyclic call of Main function
* @details        (ECUC_Can_00484) This parameter describes the period for cyclic call to Can_MainFunction_Read or Can_MainFunction_Write depending on the referring item. Unit is seconds. 
*                 Different poll-cycles will be configurable if more than one CanMainFunctionPeriod is configured. 
*                 In this case multiple Can_MainFunction_Read() or Can_MainFunction_Write() will be provided by the CAN Driver module..
*
*/
[!IF "num:i(count(CanGeneral/CanMainFunctionRWPeriods/*)) = 1"!]
    #define CAN_MAINFUNCTION_PERIOD         ([!"CanGeneral/CanMainFunctionRWPeriods/*[1]/CanMainFunctionPeriod"!]F)
    [!IF "$rx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_PERIOD_READ    ([!"CanGeneral/CanMainFunctionRWPeriods/*[1]/CanMainFunctionPeriod"!]F)
        #define CAN_MAINFUNCTION_MULTIPLE_READ  (STD_OFF)
    [!ENDIF!]
    [!IF "$tx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_PERIOD_WRITE   ([!"CanGeneral/CanMainFunctionRWPeriods/*[1]/CanMainFunctionPeriod"!]F)
        #define CAN_MAINFUNCTION_MULTIPLE_WRITE (STD_OFF)
    [!ENDIF!]
[!ELSE!]
    [!IF "$rx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_MULTIPLE_READ   (STD_ON)
    [!ENDIF!]
    [!IF "$tx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_MULTIPLE_WRITE   (STD_ON)
    [!ENDIF!]
    [!LOOP "CanGeneral/CanMainFunctionRWPeriods/*"!]
        #define CAN_MAINFUNCTION_PERIOD_[!"@index"!]       ([!"CanMainFunctionPeriod"!]F)
        [!IF "$rx_pol_en = 1"!]
            #define CAN_MAINFUNCTION_PERIOD_READ_[!"@index"!]       ([!"CanMainFunctionPeriod"!]F)
        [!ENDIF!]
        [!IF "$tx_pol_en = 1"!]
            #define CAN_MAINFUNCTION_PERIOD_WRITE_[!"@index"!]       ([!"CanMainFunctionPeriod"!]F)
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDIF!]

/*
* @brief          Periods for cyclic call of Main function Mode
* @details        (CAN376_Conf) This parameter describes the period for cyclic call to Can_MainFunction_Mode. Unit is seconds.
*
*/
#define CAN_MAINFUNCTION_MODE_PERIOD   [!WS "1"!][!SELECT "CanGeneral"!][!"num:i(CanMainFunctionModePeriod)"!]U[!ENDSELECT!][!CR!]

[!VAR "BccSupport" = "0"!][!LOOP "CanConfigSet/CanController/*"!][!IF "CanBccSupport = 'true'"!][!VAR "BccSupport" = "1"!][!ENDIF!][!ENDLOOP!]
/*
* @brief    Defines if Backwards Compatibility Configuration (BCC) feature of CAN controller is used in the configuration.
*           If BCC feature of CAN controller is enabled, Individual Rx masking and queue feature are disabled.
*           If BCC feature of CAN controller is disabled, Individual Rx masking and queue feature are enabled.
*/
#define CAN_BCC_SUPPORT_ENABLE [!WS "1"!][!IF "$BccSupport = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

[!NOCODE!]
[!VAR "Can_hardware_ob_id" = "0"!]
[!LOOP "CanConfigSet/CanHardwareObject/*"!]
    [!IF "$Can_hardware_ob_id < CanObjectId"!]
        [!VAR "Can_hardware_ob_id" = "CanObjectId"!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDNOCODE!]
/*
@brief    Macro used to define the maximum of Can object IDs configured  .
*/
#define CAN_MAX_OBJECT_ID ((uint32)[!"num:i($Can_hardware_ob_id + 1)"!]U)

#define CAN_CONTROLLER_REFERENCE_COUNTER   [!WS "1"!][!"(num:i(ecu:get('Can.CanConfigSet.CanController')))"!][!CR!]

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

[!VAR "Can_Controller_counter" = "0"!]
[!VAR "Can_Controller_Reference" = "(num:i(ecu:get('Can.CanConfigSet.CanController'))-1)"!]
[!FOR "Can_Controller_counter" = "0" TO "num:i($Can_Controller_Reference)"!]
    [!VAR "Can_Mb_counter" = "text:split(ecu:get('Can.CanConfigSet.CanController.NoMB'), ',')[position()-1 = $Can_Controller_counter]"!]
    [!IF "($Can_Mb_counter) <=32"!]
       /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
        #define CAN_MB_CONTROLLER_[!"num:i($Can_Controller_counter+1)"!]     32U
    [!ELSEIF "(($Can_Mb_counter > 32) and ($Can_Mb_counter <=64))"!]
        /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */     
        #define CAN_MB_CONTROLLER_[!"num:i($Can_Controller_counter+1)"!]     64U
    [!ELSEIF "(($Can_Mb_counter > 64) and ($Can_Mb_counter <=96))"!]
        /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
        #define CAN_MB_CONTROLLER_[!"num:i($Can_Controller_counter+1)"!]     96U
    [!ENDIF!]    
[!ENDFOR!]

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
[!IF "node:exists(CanGeneral/CanLPduReceiveCalloutFunction)"!]
    [!SELECT "CanGeneral"!]
        [!IF "(normalize-space(CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
            /*
            @brief    This inclusion shall be made here, after the definition of other defines  which are used by the included file.
            */
            /** @violates @ref Can_Cfg_h_REF_2 Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.*/
            #define CanLPduReceiveCalloutFunction     ([!"normalize-space(CanLPduReceiveCalloutFunction)"!])
        [!ENDIF!]
    [!ENDSELECT!]
[!ENDIF!]

[!ENDINDENT!]

#ifdef __cplusplus
}
#endif

#endif /* _CAN_CFG_H_ */

/** @} */
